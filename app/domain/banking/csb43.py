from datetime import datetime, date
from decimal import Decimal
from typing import List, Optional
import io

from app.domain.banking.entities import BankStatement, BankStatementLine, StatementStatus

class CSB43Parser:
    """
    Parser for Spanish Norma 43 (CSB43) bank statement files.
    Structure:
    - 11: Header (Account Start)
    - 22: Transaction Line
    - 23: Transaction Concepts (Optional, Multiple)
    - 33: Footer (Account End)
    - 88: End of File
    """

    def parse(self, filename: str, content: bytes) -> List[BankStatement]:
        statements = []
        lines = content.decode('latin-1', errors='replace').splitlines()
        
        current_statement: Optional[BankStatement] = None
        current_lines: List[BankStatementLine] = []
        last_line_obj: Optional[BankStatementLine] = None
        
        for line_str in lines:
            if not line_str.strip():
                continue
                
            record_type = line_str[:2]
            
            if record_type == "11":
                # Header: New Account Statement
                if current_statement:
                    # Save previous statement if exists (though usually 33 closes it)
                    current_statement.lines = current_lines
                    statements.append(current_statement)
                
                bank_code = line_str[2:6]
                branch_code = line_str[6:10]
                account_number = line_str[10:20]
                start_date_str = line_str[20:26]
                end_date_str = line_str[26:32]
                
                # Initial Balance
                sign = line_str[32] # 1=Debit, 2=Credit
                amount_str = line_str[33:47]
                initial_balance = self._parse_amount(amount_str, sign)
                
                currency_code = line_str[47:50] # 978 = EUR
                
                account_id_formatted = f"{bank_code}{branch_code}{account_number}"
                
                current_statement = BankStatement(
                    id=None, # Generated by repository or service
                    account_id=account_id_formatted, # Temporary ID, service maps to real ID
                    filename=filename,
                    upload_date=datetime.now(),
                    status=StatementStatus.PENDING,
                    lines=[]
                )
                current_lines = []
                last_line_obj = None

            elif record_type == "22":
                # Transaction
                if not current_statement:
                    continue
                    
                txn_date_str = line_str[10:16]
                val_date_str = line_str[16:22]
                common_concept = line_str[22:24]
                own_concept = line_str[24:27]
                sign = line_str[27] # 1=Debit, 2=Credit
                amount_str = line_str[28:42]
                doc_number = line_str[42:52]
                reference1 = line_str[52:90].strip()
                
                amount = self._parse_amount(amount_str, sign)
                date_obj = self._parse_date(txn_date_str)
                val_date_obj = self._parse_date(val_date_str)
                
                # Create Line
                msg_id = f"{current_statement.account_id}-{date_obj}-{len(current_lines)}"
                
                new_line = BankStatementLine(
                    id=None, # Service assigns UUID
                    statement_id="", # Assigned later
                    date=date_obj,
                    value_date=val_date_obj,
                    amount=float(amount),
                    concept=reference1,
                    balance=0.0, # Calculated later or from 33? 22 doesn't have balance
                    status="PENDING"
                )
                current_lines.append(new_line)
                last_line_obj = new_line
                
            elif record_type == "23":
                # Extra Info (continues previous 22)
                if last_line_obj:
                    extra_text = line_str[4:80].strip()
                    last_line_obj.concept += " " + extra_text
                    
            elif record_type == "33":
                # Footer: End of Account
                if current_statement:
                    # Final Balance Check
                    sign = line_str[59]
                    amount_str = line_str[60:74]
                    final_balance = self._parse_amount(amount_str, sign)
                    
                    # We could verify logic here, but for now just save
                    current_statement.lines = current_lines
                    statements.append(current_statement)
                    current_statement = None
                    current_lines = []
                    last_line_obj = None

            elif record_type == "88":
                # End of File
                break
                
        # Catch any trailing statement not closed by 33 (rare but possible)
        if current_statement:
            current_statement.lines = current_lines
            statements.append(current_statement)
            
        return statements

    def _parse_amount(self, amount_str: str, sign: str) -> Decimal:
        # Amount format: 12 digits integer, 2 digits decimal
        # Sign: 1 = Debit (-), 2 = Credit (+)
        try:
            val = Decimal(amount_str) / 100
            if sign == '1': # Debit
                return -val
            return val # Credit
        except:
            return Decimal(0)

    def _parse_date(self, date_str: str) -> date:
        # Format YYMMDD
        try:
            return datetime.strptime(date_str, "%y%m%d").date()
        except:
            return date.today()
